#pragma once

namespace xlang
{
    static void write_preamble(writer& w)
    {
        if (settings.license)
        {
            w.write(R"(// cppxlang v%

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

)", XLANG_VERSION_STRING);
        }
        else
        {
            w.write(R"(// WARNING: Please don't edit this file. It was generated by cppxlang v%

)", XLANG_VERSION_STRING);
        }
    }

    static void write_version_assert(writer& w)
    {
        w.write_root_include("base");
        auto format = R"(static_assert(xlang::check_version(CPPXLANG_VERSION, "%"), "Mismatched cppxlang headers.");
)";
        w.write(format, XLANG_VERSION_STRING);
    }

    static void write_include_guard(writer& w)
    {
        auto format = R"(#pragma once
)";

        w.write(format);
    }

    static void write_open_file_guard(writer& w, std::string_view const& file_name, char impl = 0)
    {
        std::string mangled_name;

        for (auto&& c : file_name)
        {
            mangled_name += c == '.' ? '_' : c;
        }

        if (impl)
        {
            mangled_name += '_';
            mangled_name += impl;
        }

        auto format = R"(#ifndef XLANG_%_H
#define XLANG_%_H
)";

        w.write(format, mangled_name, mangled_name);
    }

    static void write_close_file_guard(writer& w)
    {
        auto format = R"(#endif
)";

        w.write(format);
    }

    static void write_parent_depends(writer& w, cache const& c, std::string_view const& type_namespace)
    {
        auto pos = type_namespace.rfind('.');

        if (pos == std::string::npos)
        {
            return;
        }

        auto parent = type_namespace.substr(0, pos);
        auto found = c.namespaces().find(parent);

        if (found != c.namespaces().end() && has_projected_types(found->second))
        {
            w.write_root_include(parent);
        }
        else
        {
            write_parent_depends(w, c, parent);
        }
    }

    static void write_pch(writer& w)
    {
        auto format = R"(#include "%"
)";

        if (!settings.component_pch.empty())
        {
            w.write(format, settings.component_pch);
        }
    }

    static void write_impl_namespace(writer& w)
    {
        auto format = R"(namespace xlang::impl
{
)";

        w.write(format);
    }

    static void write_std_namespace(writer& w)
    {
        w.write(R"(namespace std
{
)");
    }

    static void write_type_namespace(writer& w, std::string_view const& ns)
    {
        auto format = R"(namespace xlang::@
{
)";

        w.write(format, ns);
    }

    static void write_close_namespace(writer& w)
    {
        auto format = R"(}
)";

        w.write(format);
    }

    static void write_enum_field(writer& w, Field const& field)
    {
        auto format = R"(        % = %,
)";

        if (auto constant = field.Constant())
        {
            w.write(format, field.Name(), *constant);
        }
    }

    static void write_enum(writer& w, TypeDef const& type)
    {
        auto format = R"(    enum class % : %
    {
%    };
)";

        auto fields = type.FieldList();
        w.write(format, type.TypeName(), fields.first.Signature().Type(), bind_each<write_enum_field>(fields));
    }

    static void write_generic_typenames(writer& w, std::pair<GenericParam, GenericParam> const& params)
    {
        separator s{ w };

        for (auto&& param : params)
        {
            s();
            w.write("typename %", param);
        }
    }

    static void write_comma_generic_typenames(writer& w, std::pair<GenericParam, GenericParam> const& params)
    {
        for (auto&& param : params)
        {
            w.write(", typename %", param);
        }
    }

    static void write_comma_generic_types(writer& w, std::pair<GenericParam, GenericParam> const& params)
    {
        for (auto&& param : params)
        {
            w.write(", %", param);
        }
    }

    static void write_forward(writer& w, TypeDef const& type)
    {
        type_name type_name(type);

        if (get_category(type) == category::enum_type)
        {
            auto format = R"(    enum class % : %;
)";

            w.write(format, type_name.name, type.FieldList().first.Signature().Type());
            return;
        }

        if (type_name == "Foundation.DateTime" ||
            type_name == "Foundation.TimeSpan")
        {
            // Don't forward declare these since they're not structs.
            return;
        }

        auto generics = type.GenericParam();

        if (empty(generics))
        {
            auto format = R"(    struct %;
)";

            w.write(format, type_name.name);
            return;
        }

        auto format = R"(    template <%> struct %;
)";

        w.write(format,
            bind<write_generic_typenames>(generics),
            remove_tick(type_name.name));
    }

    static void write_enum_flag(writer& w, TypeDef const& type)
    {
        if (!has_attribute(type, "System", "FlagsAttribute"))
        {
            return;
        }

        auto format = R"(    template<> struct is_enum_flag<%> : std::true_type
    {
    };
)";

        w.write(format, type);
    }

    static void write_guid_value(writer& w, std::vector<FixedArgSig> const& args)
    {
        using std::get;

        w.write_printf("0x%08X,0x%04X,0x%04X,{ 0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X,0x%02X }",
            get<uint32_t>(get<ElemSig>(args[0].value).value),
            get<uint16_t>(get<ElemSig>(args[1].value).value),
            get<uint16_t>(get<ElemSig>(args[2].value).value),
            get<uint8_t>(get<ElemSig>(args[3].value).value),
            get<uint8_t>(get<ElemSig>(args[4].value).value),
            get<uint8_t>(get<ElemSig>(args[5].value).value),
            get<uint8_t>(get<ElemSig>(args[6].value).value),
            get<uint8_t>(get<ElemSig>(args[7].value).value),
            get<uint8_t>(get<ElemSig>(args[8].value).value),
            get<uint8_t>(get<ElemSig>(args[9].value).value),
            get<uint8_t>(get<ElemSig>(args[10].value).value));
    }

    static void write_category(writer& w, TypeDef const& type, std::string_view const& category)
    {
        auto generics = type.GenericParam();

        if (empty(generics))
        {
            auto format = R"(    template <> struct category<%>
    {
        using type = %;
    };
)";

            w.write(format, type, category);
        }
        else
        {
            auto format = R"(    template <%> struct category<%>
    {
        using type = pinterface_category<%>;
        static constexpr guid value{ % };
    };
)";

            auto attribute = get_attribute(type, "Foundation.Metadata", "GuidAttribute");

            if (!attribute)
            {
                throw_invalid("'Foundation.Metadata.GuidAttribute' attribute for type '", type.TypeNamespace(), ".", type.TypeName(), "' not found");
            }

            w.write(format,
                bind<write_generic_typenames>(generics),
                type,
                bind_list(", ", generics),
                bind<write_guid_value>(attribute.Value().FixedArgs()));
        }
    }

    static void write_generic_names(writer& w, std::pair<GenericParam, GenericParam> const& params)
    {
        bool first{ true };

        for (auto&& param : params)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                w.write(R"(, u8", ")");
            }
            w.write(", name_v<%>", param.Name());
        }
    }

    static void write_name(writer& w, TypeDef const& type)
    {
        type_name type_name(type);
        auto generics = type.GenericParam();

        if (empty(generics))
        {
            auto format = R"(    template <> struct name<%>
    {
        static constexpr auto & value{ u8"%.%" };
    };
)";

            w.write(format, type, type_name.name_space, type_name.name);
        }
        else
        {
            auto format = R"(    template <%> struct name<%>
    {
        static constexpr auto value{ zcombine(u8"%.%<"%, u8">") };
    };
)";

            w.write(format,
                bind<write_generic_typenames>(generics),
                type,
                type_name.name_space,
                type_name.name,
                bind<write_generic_names>(generics));
        }
    }

    static void write_guid(writer& w, TypeDef const& type)
    {
        auto generics = type.GenericParam();

        if (empty(generics))
        {
            auto format = R"(    template <> struct guid_storage<%>
    {
        static constexpr guid value{ % };
    };
)";

            auto attribute = get_attribute(type, "Foundation.Metadata", "GuidAttribute");

            if (!attribute)
            {
                throw_invalid("'Foundation.Metadata.GuidAttribute' attribute for type '", type.TypeNamespace(), ".", type.TypeName(), "' not found");
            }

            w.write(format,
                type,
                bind<write_guid_value>(attribute.Value().FixedArgs()));
        }
        else
        {
            auto format = R"(    template <%> struct guid_storage<%>
    {
        static constexpr guid value{ pinterface_guid<%>::value };
    };
)";

            w.write(format,
                bind<write_generic_typenames>(generics),
                type,
                type);
        }
    }

    static void write_default_interface(writer& w, TypeDef const& type)
    {
        if (auto default_interface = get_default_interface(type))
        {
            auto format = R"(    template <> struct default_interface<%>
{
    using type = %;
};
)";
            w.write(format, type, default_interface);
        }
    }

    static void write_struct_category(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <> struct category<%>
    {
        using type = struct_category<%>;
    };
)";

        w.write(format, type, bind_list(", ", type.FieldList()));
    }

    static void write_array_size_name(writer& w, Param const& param)
    {
        if (w.param_names)
        {
            w.write(" __%Size", param.Name());
        }
    }

    static void write_abi_arg_in(writer& w, TypeSig const& type)
    {
        if (std::holds_alternative<GenericTypeIndex>(type.Type()))
        {
            w.write("arg_in<%>", type);
        }
        else
        {
            w.write(type);
        }
    }

    static void write_abi_arg_out(writer& w, TypeSig const& type)
    {
        if (std::holds_alternative<GenericTypeIndex>(type.Type()))
        {
            w.write("arg_out<%>", type);
        }
        else
        {
            w.write("%*", type);
        }
    }

    static void write_abi_params(writer& w, method_signature const& method_signature)
    {
        w.abi_types = true;
        separator s{ w };

        for (auto&& [param, param_signature] : method_signature.params())
        {
            s();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "uint32_t%, %";
                }
                else if (param_signature->ByRef())
                {
                    format = "uint32_t*%, %*";
                }
                else
                {
                    format = "uint32_t%, %";
                }

                w.write(format, bind<write_array_size_name>(param), bind<write_abi_arg_out>(param_signature->Type()));
            }
            else
            {
                if (param.Flags().In())
                {
                    write_abi_arg_in(w, param_signature->Type());

                    if (is_const(*param_signature))
                    {
                        w.write(" const&");
                    }
                }
                else
                {
                    write_abi_arg_out(w, param_signature->Type());
                }
            }

            if (w.param_names)
            {
                w.write(" %", param.Name());
            }
        }

        if (method_signature.return_signature())
        {
            s();

            auto const& type = method_signature.return_signature().Type();

            if (type.is_szarray())
            {
                w.write("uint32_t* __%Size, %**", method_signature.return_param_name(), type);
            }
            else
            {
                write_abi_arg_out(w, type);
            }

            if (w.param_names)
            {
                w.write(" %", method_signature.return_param_name());
            }
        }
    }

    bool can_take_ownership_of_return_type(method_signature const& signature)
    {
        TypeSig const& return_signature = signature.return_signature().Type();

        if (std::holds_alternative<GenericTypeInstSig>(return_signature.Type()))
        {
            return true;
        }

        if (auto type_def = std::get_if<coded_index<TypeDefOrRef>>(&return_signature.Type()))
        {
            auto category = category::interface_type;

            if (type_def->type() == TypeDefOrRef::TypeRef)
            {
                auto type_ref = type_def->TypeRef();

                if (type_name(type_ref) == "System.Guid")
                {
                    return false;
                }

                category = get_category(find_required(type_ref));
            }
            else if (type_def->type() == TypeDefOrRef::TypeDef)
            {
                category = get_category(type_def->TypeDef());
            }

            return category == category::class_type || category == category::interface_type || category == category::delegate_type;
        }

        if (auto element_type = std::get_if<ElementType>(&return_signature.Type()))
        {
            return *element_type == ElementType::String || *element_type == ElementType::Object;
        }

        return false;
    }

    static void write_abi_args(writer& w, method_signature const& method_signature)
    {
        separator s{ w };

        for (auto&& [param, param_signature] : method_signature.params())
        {
            s();
            auto param_name = param.Name();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "%.size(), get_abi(%)";
                }
                else if (param_signature->ByRef())
                {
                    format = "impl::put_size_abi(%), put_abi(%)";
                }
                else
                {
                    format = "%.size(), put_abi(%)";
                }

                w.write(format, param_name, param_name);
            }
            else
            {
                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());

                    if (wrap_abi(param_signature->Type()))
                    {
                        w.write("get_abi(%)", param_name);
                    }
                    else
                    {
                        w.write(param_name);
                    }
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    if (wrap_abi(param_signature->Type()))
                    {
                        w.write("put_abi(%)", param_name);
                    }
                    else
                    {
                        w.write("&%", param_name);
                    }
                }
            }
        }

        if (method_signature.return_signature())
        {
            s();
            auto const& type = method_signature.return_signature().Type();
            auto param_name = method_signature.return_param_name();

            if (type.is_szarray())
            {
                w.write("&%_impl_size, &%", param_name, param_name);
            }
            else
            {
                if (!can_take_ownership_of_return_type(method_signature) && wrap_abi(type))
                {
                    w.write("put_abi(%)", param_name);
                }
                else
                {
                    w.write("&%", param_name);
                }
            }
        }
    }

    static void write_interface_abi(writer& w, TypeDef const& type)
    {
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        w.abi_types = false;

        if (empty(generics))
        {
            auto format = R"(    template <> struct abi<%>
    {
        struct XLANG_NOVTABLE type : xlang_object_abi
        {
)";

            w.write(format, type);
        }
        else
        {
            auto format = R"(    template <%> struct abi<%>
    {
        struct XLANG_NOVTABLE type : xlang_object_abi
        {
)";

            w.write(format,
                bind<write_generic_typenames>(generics),
                type);
        }


        auto format = R"(            virtual xlang_error_info* XLANG_CALL %(%) noexcept = 0;
)";

        for (auto&& method : type.MethodList())
        {
            method_signature signature{ method };
            w.write(format, get_abi_name(method), bind<write_abi_params>(signature));
        }

        w.write(R"(        };
    };
)");
    }

    static void write_delegate_abi(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <%> struct abi<%>
    {
        struct XLANG_NOVTABLE type : unknown_abi
        {
            virtual xlang_error_info* XLANG_CALL Invoke(%) noexcept = 0;
        };
    };
)";

        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        auto method = get_delegate_method(type);
        method_signature signature{ method };
        w.abi_types = false;

        w.write(format,
            bind<write_generic_typenames>(generics),
            type,
            bind<write_abi_params>(signature));
    }

    static void write_field_abi(writer& w, Field const& field)
    {
        w.write("        % %;\n", get_field_abi(w, field), field.Name());
    }

    static void write_struct_abi(writer& w, TypeDef const& type)
    {
        w.abi_types = true;

        auto format = R"(    struct struct_%
    {
%    };
    template <> struct abi<@::%>
    {
        using type = struct_%;
    };
)";

        type_name type_name(type);
        auto impl_name = get_impl_name(type_name.name_space, type_name.name);

        w.write(format,
            impl_name,
            bind_each<write_field_abi>(type.FieldList()),
            type_name.name_space, type_name.name,
            impl_name);

    }

    static void write_consume_params(writer& w, method_signature const& signature)
    {
        separator s{ w };

        for (auto&& [param, param_signature] : signature.params())
        {
            s();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "array_view<% const>";
                }
                else if (param_signature->ByRef())
                {
                    format = "com_array<%>&";
                }
                else
                {
                    format = "array_view<%>";
                }

                w.write(format, param_signature->Type().Type());
            }
            else
            {
                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());
                    w.consume_types = true;

                    auto param_type = std::get_if<ElementType>(&param_signature->Type().Type());

                    if (param_type && *param_type != ElementType::String && *param_type != ElementType::Object)
                    {
                        w.write("%", param_signature->Type());
                    }
                    else if (std::holds_alternative<GenericTypeIndex>(param_signature->Type().Type()))
                    {
                        w.write("impl::param_type<%> const&", param_signature->Type());
                    }
                    else
                    {
                        w.write("% const&", param_signature->Type());
                    }

                    w.consume_types = false;
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    w.write("%&", param_signature->Type());
                }
            }

            w.write(" %", param.Name());
        }
    }

    static void write_implementation_params(writer& w, method_signature const& method_signature)
    {
        separator s{ w };

        for (auto&& [param, param_signature] : method_signature.params())
        {
            s();

            if (param_signature->Type().is_szarray())
            {
                std::string_view format;

                if (param.Flags().In())
                {
                    format = "array_view<% const>";
                }
                else if (param_signature->ByRef())
                {
                    format = "com_array<%>&";
                }
                else
                {
                    format = "array_view<%>";
                }

                w.write(format, param_signature->Type().Type());
            }
            else
            {
                if (param.Flags().In())
                {
                    XLANG_ASSERT(!param.Flags().Out());

                    auto param_type = std::get_if<ElementType>(&param_signature->Type().Type());

                    if (w.async_types || (param_type && *param_type != ElementType::String && *param_type != ElementType::Object))
                    {
                        w.write("%", param_signature->Type());
                    }
                    else
                    {
                        w.write("% const&", param_signature->Type());
                    }
                }
                else
                {
                    XLANG_ASSERT(!param.Flags().In());
                    XLANG_ASSERT(param.Flags().Out());

                    w.write("%&", param_signature->Type());
                }
            }

            w.write(" %", param.Name());
        }
    }

    static void write_consume_declaration(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };
        w.async_types = is_async(method, signature);
        auto method_name = get_name(method);
        auto type = method.Parent();

        w.write("        % %(%) const%;\n",
            signature.return_signature(),
            method_name,
            bind<write_consume_params>(signature),
            is_noexcept(method) ? " noexcept" : "");

        if (is_add_overload(method))
        {
            auto format = R"(        using %_revoker = impl::event_revoker<%, &impl::abi_t<%>::remove_%>;
        %_revoker %(auto_revoke_t, %) const;
)";

            w.write(format,
                method_name,
                type,
                type,
                method_name,
                method_name,
                method_name,
                bind<write_consume_params>(signature));
        }
    }

    static void write_consume_return_type(writer& w, method_signature const& signature)
    {
        if (!signature.return_signature())
        {
            return;
        }

        if (signature.return_signature().Type().is_szarray())
        {
            auto format = R"(
        uint32_t %_impl_size;
        %* %;)";

            w.abi_types = true;

            w.write(format,
                signature.return_param_name(),
                signature.return_signature(),
                signature.return_param_name());

            w.abi_types = false;
        }
        else if (can_take_ownership_of_return_type(signature))
        {
            auto format = "\n        void* %;";
            w.write(format, signature.return_param_name());
        }
        else if (std::holds_alternative<GenericTypeIndex>(signature.return_signature().Type().Type()))
        {
            auto format = "\n        % %{ empty_value<%>() };";
            w.write(format, signature.return_signature(), signature.return_param_name(), signature.return_signature());
        }
        else
        {
            auto format = "\n        % %;";
            w.write(format, signature.return_signature(), signature.return_param_name());
        }
    }

    static void write_consume_return_statement(writer& w, method_signature const& signature)
    {
        if (!signature.return_signature())
        {
            return;
        }

        if (signature.return_signature().Type().is_szarray())
        {
            w.write("\n        return { %, %_impl_size, take_ownership_from_abi };",
                signature.return_param_name(),
                signature.return_param_name());
        }
        else if (can_take_ownership_of_return_type(signature))
        {
            w.write("\n        return { %, take_ownership_from_abi };", signature.return_param_name());
        }
        else
        {
            w.write("\n        return %;", signature.return_param_name());
        }
    }

    static void write_consume_args(writer& w, method_signature const& signature)
    {
        separator s{ w };

        for (auto&& [param, param_signature] : signature.params())
        {
            s();
            w.write(param.Name());
        }
    }

    static void write_consume_definitions(writer& w, TypeDef const& type)
    {
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        auto type_name = type.TypeName();

        if (!empty(generics))
        {
            type_name = remove_tick(type_name);
        }

        auto type_namespace = type.TypeNamespace();
        auto type_impl_name = get_impl_name(type_namespace, type_name);

        for (auto&& method : type.MethodList())
        {
            auto method_name = get_name(method);
            method_signature signature{ method };
            w.async_types = is_async(method, signature);

            std::string_view format;

            if (is_noexcept(method))
            {
                format = R"(    template <typename D%> % consume_%<D%>::%(%) const noexcept
    {%
        XLANG_VERIFY_(0, XLANG_SHIM(%)->%(%));%
    }
)";
            }
            else
            {
                format = R"(    template <typename D%> % consume_%<D%>::%(%) const
    {%
        check_xlang_error(XLANG_SHIM(%)->%(%));%
    }
)";
            }

            w.write(format,
                bind<write_comma_generic_typenames>(generics),
                signature.return_signature(),
                type_impl_name,
                bind<write_comma_generic_types>(generics),
                method_name,
                bind<write_consume_params>(signature),
                bind<write_consume_return_type>(signature),
                type,
                get_abi_name(method),
                bind<write_abi_args>(signature),
                bind<write_consume_return_statement>(signature));

            if (is_add_overload(method))
            {
                format = R"(    template <typename D%> typename consume_%<D%>::%_revoker consume_%<D%>::%(auto_revoke_t, %) const
    {
        return impl::make_event_revoker<D, %_revoker>(this, %(%));
    }
)";

                w.write(format,
                    bind<write_comma_generic_typenames>(generics),
                    type_impl_name,
                    bind<write_comma_generic_types>(generics),
                    method_name,
                    type_impl_name,
                    bind<write_comma_generic_types>(generics),
                    method_name,
                    bind<write_consume_params>(signature),
                    method_name,
                    method_name,
                    bind<write_consume_args>(signature));
            }
        }
    }

    static void write_consume_extensions(writer& w, TypeDef const& type)
    {
        type_name type_name(type);

        if (type_name == "Foundation.Collections.IIterator`1")
        {
            w.write(R"(
        auto& operator++()
        {
            if (!MoveNext())
            {
                static_cast<D&>(*this) = nullptr;
            }

            return *this;
        }

        T operator*() const
        {
            return Current();
        }
)");
        }
        else if (type_name == "Foundation.Collections.IKeyValuePair`2")
        {
            w.write(R"(
        bool operator==(Foundation::Collections::IKeyValuePair<K, V> const& other) const
        {
            return Key() == other.Key() && Value() == other.Value();
        }

        bool operator!=(Foundation::Collections::IKeyValuePair<K, V> const& other) const
        {
            return !(*this == other);
        }
)");
        }
        else if (type_name == "Foundation.Collections.IMapView`2")
        {
            w.write(R"(
        auto TryLookup(param_type<K> const& key) const noexcept
        {
            if constexpr (std::is_base_of_v<Foundation::IUnknown, V>)
            {
                V result{ nullptr };
                com_ptr<xlang_error_info> error_info{
                    XLANG_SHIM(Foundation::Collections::IMapView<K, V>)->Lookup(get_abi(key), put_abi(result)),
                    take_ownership_from_abi
                };
                return result;
            }
            else
            {
                std::optional<V> result;
                V value{ empty_value<V>() };

                com_ptr<xlang_error_info> error_info{
                    XLANG_SHIM(Foundation::Collections::IMapView<K, V>)->Lookup(get_abi(key), put_abi(value)),
                    take_ownership_from_abi
                };
                if (nullptr == error_info)
                {
                    result = std::move(value);
                }

                return result;
            }
        }
)");
        }
        else if (type_name == "Foundation.Collections.IMap`2")
        {
            w.write(R"(
        auto TryLookup(param_type<K> const& key) const noexcept
        {
            if constexpr (std::is_base_of_v<Foundation::IUnknown, V>)
            {
                V result{ nullptr };
                com_ptr<xlang_error_info> error_info{
                    XLANG_SHIM(Foundation::Collections::IMap<K, V>)->Lookup(get_abi(key), put_abi(result)),
                    take_ownership_from_abi
                };
                return result;
            }
            else
            {
                std::optional<V> result;
                V value{ empty_value<V>() };

                com_ptr<xlang_error_info> error_info{
                    XLANG_SHIM(Foundation::Collections::IMap<K, V>)->Lookup(get_abi(key), put_abi(value)),
                    take_ownership_from_abi
                };
                if (nullptr == error_info)
                {
                    result = std::move(value);
                }

                return result;
            }
        }
)");
        }
        else if (type_name == "Foundation.IAsyncAction")
        {
            w.write(R"(        void get() const
        {
            blocking_suspend(static_cast<Foundation::IAsyncAction const&>(static_cast<D const&>(*this)));
            GetResults();
        })");
        }
        else if (type_name == "Foundation.IAsyncOperation`1")
        {
            w.write(R"(        TResult get() const
        {
            blocking_suspend(static_cast<Foundation::IAsyncOperation<TResult> const&>(static_cast<D const&>(*this)));
            return GetResults();
        })");
        }
        else if (type_name == "Foundation.IAsyncActionWithProgress`1")
        {
            w.write(R"(        void get() const
        {
            blocking_suspend(static_cast<Foundation::IAsyncActionWithProgress<TProgress> const&>(static_cast<D const&>(*this)));
            GetResults();
        })");
        }
        else if (type_name == "Foundation.IAsyncOperationWithProgress`2")
        {
            w.write(R"(        TResult get() const
        {
            blocking_suspend(static_cast<Foundation::IAsyncOperationWithProgress<TResult, TProgress> const&>(static_cast<D const&>(*this)));
            return GetResults();
        })");
        }
    }

    static void write_interface_extensions(writer& w, TypeDef const& type)
    {
        type_name type_name(type);

        if (type_name == "Foundation.Collections.IIterator`1")
        {
            w.write(R"(
        using iterator_category = std::input_iterator_tag;
        using value_type = T;
        using difference_type = ptrdiff_t;
        using pointer = T*;
        using reference = T&;
)");
        }
    }

    static void write_consume(writer& w, TypeDef const& type)
    {
        w.abi_types = false;
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        auto type_name = type.TypeName();

        if (!empty(generics))
        {
            type_name = remove_tick(type_name);
        }

        auto type_namespace = type.TypeNamespace();
        auto impl_name = get_impl_name(type_namespace, type_name);

        if (empty(generics))
        {
            auto format = R"(    template <typename D>
    struct consume_%
    {
%%    };
    template <> struct consume<%>
    {
        template <typename D> using type = consume_%<D>;
    };
)";


            w.write(format,
                impl_name,
                bind_each<write_consume_declaration>(type.MethodList()),
                bind<write_consume_extensions>(type),
                type,
                impl_name);
        }
        else
        {
            auto format = R"(    template <typename D, %>
    struct consume_%
    {
%%    };
    template <%> struct consume<%>
    {
        template <typename D> using type = consume_%<D, %>;
    };
)";


            w.write(format,
                bind<write_generic_typenames>(generics),
                impl_name,
                bind_each<write_consume_declaration>(type.MethodList()),
                bind<write_consume_extensions>(type),
                bind<write_generic_typenames>(generics),
                type,
                impl_name,
                bind_list(", ", generics));
        }
    }

    static void write_produce_params(writer& w, method_signature const& signature)
    {
        w.param_names = true;
        write_abi_params(w, signature);
    }

    template <typename T>
    static void write_produce_cleanup_param(writer& w, T const& param_signature, std::string_view const& param_name, bool out)
    {
        TypeSig const& signature = param_signature.Type();
        w.abi_types = false;
        bool clear{};
        bool optional{};
        bool zero{};

        call(signature.Type(),
            [&](ElementType type)
            {
                if (out && type == ElementType::Object)
                {
                    optional = true;
                }
                else if (type == ElementType::String || type == ElementType::Object)
                {
                    clear = true;
                }
            },
            [&](coded_index<TypeDefOrRef> const& index)
            {
                XLANG_ASSERT(index.type() == TypeDefOrRef::TypeDef || index.type() == TypeDefOrRef::TypeRef);

                TypeDef type;

                if (index.type() == TypeDefOrRef::TypeDef)
                {
                    type = index.TypeDef();
                }
                else if (index.type() == TypeDefOrRef::TypeRef)
                {
                    type = find(index.TypeRef());
                }

                if (type)
                {
                    auto category = get_category(type);

                    clear = category == category::class_type || category == category::interface_type || category == category::delegate_type;
                    zero = category == category::struct_type;
                }
            },
            [&](GenericTypeIndex const&)
            {
                clear = true;
            },
            [](GenericMethodTypeIndex const&)
            {
                throw_invalid("Generic methods not supported.");
            },
            [&](GenericTypeInstSig const&)
            {
                clear = true;
            });

        if (signature.is_szarray())
        {
            if constexpr (std::is_same_v<RetTypeSig, T>)
            {
                clear = true;
            }
            else if (param_signature.ByRef())
            {
                clear = true;
            }
            else if (optional || clear)
            {
                clear = false;
                zero = true;
            }
        }

        if (clear)
        {
            auto format = R"(            clear_abi(%);
)";

            w.write(format, param_name);
        }
        else if (zero)
        {
            if (signature.is_szarray())
            {
                auto format = R"(            zero_abi<%>(%, __%Size);
)";

                w.write(format,
                    signature.Type(),
                    param_name,
                    param_name);
            }
            else
            {
                auto format = R"(            zero_abi<%>(%);
)";

                w.write(format,
                    signature.Type(),
                    param_name);
            }
        }
        else if (optional)
        {
            auto format = R"(            if (%) *% = nullptr;
            Windows::Foundation::IXlangObject xlang_impl_%;
)";

            w.write(format, param_name, param_name, param_name);
        }
    }

    static void write_produce_cleanup(writer& w, method_signature const& method_signature)
    {
        for (auto&& [param, param_signature] : method_signature.params())
        {
            if (param.Flags().In())
            {
                continue;
            }

            write_produce_cleanup_param(w, *param_signature, param.Name(), true);
        }

        if (method_signature.return_signature())
        {
            write_produce_cleanup_param(w, method_signature.return_signature(), method_signature.return_param_name(), false);
        }
    }

    static void write_produce_args(writer& w, method_signature const& method_signature)
    {
        w.abi_types = false;
        separator s{ w };

        for (auto&& [param, param_signature] : method_signature.params())
        {
            s();
            auto param_name = param.Name();
            auto param_type = w.write_temp("%", param_signature->Type().Type());

            if (param_signature->Type().is_szarray())
            {
                if (param.Flags().In())
                {
                    w.write("array_view<@ const>(reinterpret_cast<@ const *>(%), reinterpret_cast<@ const *>(%) + __%Size)",
                        param_type,
                        param_type,
                        param_name,
                        param_type,
                        param_name,
                        param_name);
                }
                else if (param_signature->ByRef())
                {
                    w.write("detach_abi<@>(__%Size, %)",
                        param_type,
                        param_name,
                        param_name);
                }
                else
                {
                    w.write("array_view<@>(reinterpret_cast<@*>(%), reinterpret_cast<@*>(%) + __%Size)",
                        param_type,
                        param_type,
                        param_name,
                        param_type,
                        param_name,
                        param_name);
                }
            }
            else
            {
                if (param.Flags().In())
                {
                    if (wrap_abi(param_signature->Type()))
                    {
                        w.write("*reinterpret_cast<% const*>(&%)",
                            param_type,
                            param_name);
                    }
                    else
                    {
                        w.write(param_name);
                    }
                }
                else
                {
                    if (is_object(param_signature->Type()))
                    {
                        w.write("xlang_impl_%", param_name);
                    }
                    else if (wrap_abi(param_signature->Type()))
                    {
                        w.write("*reinterpret_cast<@*>(%)",
                            param_type,
                            param_name);
                    }
                    else
                    {
                        w.write("*%", param_name);
                    }
                }
            }
        }
    }

    static void write_produce_upcall(writer& w, MethodDef const& method, method_signature const& method_signature)
    {
        w.abi_types = false;

        if (method_signature.return_signature())
        {
            auto name = method_signature.return_param_name();

            if (method_signature.return_signature().Type().is_szarray())
            {
                w.write("std::tie(*__%Size, *%) = detach_abi(this->shim().%(%));",
                    name,
                    name,
                    get_name(method),
                    bind<write_produce_args>(method_signature));
            }
            else
            {
                w.write("*% = detach_from<%>(this->shim().%(%));",
                    name,
                    method_signature.return_signature(),
                    get_name(method),
                    bind<write_produce_args>(method_signature));
            }
        }
        else
        {
            w.write("this->shim().%(%);",
                get_name(method),
                bind<write_produce_args>(method_signature));
        }

        for (auto&& [param, param_signature] : method_signature.params())
        {
            if (param.Flags().Out() && !param_signature->Type().is_szarray() && is_object(param_signature->Type()))
            {
                auto param_name = param.Name();

                w.write("\n                if (%) *% = detach_abi(xlang_impl_%);", param_name, param_name, param_name);
            }
        }
    }

    static void write_delegate_upcall(writer& w, method_signature const& method_signature)
    {
        w.abi_types = false;

        if (method_signature.return_signature())
        {
            auto name = method_signature.return_param_name();

            if (method_signature.return_signature().Type().is_szarray())
            {
                w.write("std::tie(*__%Size, *%) = detach_abi((*this)(%))",
                    name,
                    name,
                    bind<write_produce_args>(method_signature));
            }
            else
            {
                w.write("*% = detach_from<%>((*this)(%))",
                    name,
                    method_signature.return_signature(),
                    bind<write_produce_args>(method_signature));
            }
        }
        else
        {
            w.write("(*this)(%)",
                bind<write_produce_args>(method_signature));
        }
    }

    static void write_produce_method(writer& w, MethodDef const& method)
    {
        std::string_view format;

        if (is_noexcept(method))
        {
            format = R"(        xlang_error_info* XLANG_CALL %(%) noexcept final
        {
%            typename D::abi_guard guard(this->shim());
            %
            return 0;
        }
)";
        }
        else
        {
            format = R"(        xlang_error_info* XLANG_CALL %(%) noexcept final try
        {
%            typename D::abi_guard guard(this->shim());
            %
            return nullptr;
        }
        catch (...) { return to_xlang_error(); }
)";
        }

        method_signature signature{ method };
        w.async_types = is_async(method, signature);

        w.write(format,
            get_abi_name(method),
            bind<write_produce_params>(signature),
            bind<write_produce_cleanup>(signature),
            bind<write_produce_upcall>(method, signature));
    }

    static void write_produce(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <typename D%>
    struct produce<D, %> : produce_base<D, %>
    {
%    };
)";

        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };

        w.write(format,
            bind<write_comma_generic_typenames>(generics),
            type,
            type,
            bind_each<write_produce_method>(type.MethodList()));
    }

    static void write_dispatch_overridable_method(writer& w, MethodDef const& method)
    {
        auto format = R"(    % %(%)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.%(%);
        }

        return this->shim().%(%);
    }
)";

        method_signature signature{ method };

        w.write(format,
            signature.return_signature(),
            get_name(method),
            bind<write_implementation_params>(signature),
            get_name(method),
            bind<write_consume_args>(signature),
            get_name(method),
            bind<write_consume_args>(signature));
    }

    static void write_dispatch_overridable(writer& w, TypeDef const& class_type)
    {
        auto format = R"(template <typename T, typename D>
struct XLANG_EBO produce_dispatch_to_overridable<T, D, %>
    : produce_dispatch_to_overridable_base<T, D, %>
{
%};)";

        for (auto&& [interface_name, info] : get_interfaces(w, class_type))
        {
            if (info.overridable && !info.base)
            {
                w.write(format,
                    interface_name,
                    interface_name,
                    bind_each<write_dispatch_overridable_method>(info.type.MethodList()));
            }
        }
    }

    static void write_interface_override_method(writer& w, MethodDef const& method, std::string_view const& interface_name)
    {
        auto format = R"(    template <typename D> % %T<D>::%(%) const
    {
        return shim().template try_as<%>().%(%);
    }
)";

        method_signature signature{ method };
        auto method_name = get_name(method);

        w.write(format,
            signature.return_signature(),
            interface_name,
            method_name,
            bind<write_consume_params>(signature),
            interface_name,
            method_name,
            bind<write_consume_args>(signature));
    }

    static void write_interface_override_methods(writer& w, TypeDef const& class_type)
    {
        for (auto&& [interface_name, info] : get_interfaces(w, class_type))
        {
            if (info.overridable && !info.base)
            {
                auto name = info.type.TypeName();

                w.write_each<write_interface_override_method>(info.type.MethodList(), name);
            }
        };
    }

    static void write_class_override_implements(writer& w, std::map<std::string, interface_info> const& interfaces)
    {
        bool found{};

        for (auto&& [name, info] : interfaces)
        {
            if (info.overridable)
            {
                w.write(", %", name);
                found = true;
            }
        }

        if (!found)
        {
            w.write(", Windows::Foundation::IXlangObject");
        }
    }

    static void write_class_override_requires(writer& w, std::map<std::string, interface_info> const& interfaces)
    {
        bool found{};

        for (auto&& [name, info] : interfaces)
        {
            if (!info.overridable)
            {
                w.write(", %", name);
                found = true;
            }
        }
    }

    static void write_class_override_defaults(writer& w, std::map<std::string, interface_info> const& interfaces)
    {
        bool first{ true };

        for (auto&& [name, info] : interfaces)
        {
            if (!info.overridable)
            {
                continue;
            }

            if (first)
            {
                first = false;
                w.write(",\n        %T<D>", name);
            }
            else
            {
                w.write(", %T<D>", name);
            }
        }
    }

    static void write_class_override_bases(writer& w, TypeDef const& type)
    {
        for (auto&& base : get_bases(type))
        {
            w.write(", %", base);
        }
    }

    static void write_class_override_constructors(writer& w, std::string_view const& type_name, std::map<std::string, factory_info> const& factories)
    {
        auto format = R"(        %T(%)
        {
            impl::call_factory<%, %>([&](auto&& f) { f.%(%%*this, this->m_inner); });
        }
)";

        for (auto&& [factory_name, factory] : factories)
        {
            if (!factory.composable)
            {
                continue;
            }

            for (auto&& method : factory.type.MethodList())
            {
                method_signature signature{ method };
                auto& params = signature.params();
                params.resize(params.size() - 2);

                w.write(format,
                    type_name,
                    bind<write_consume_params>(signature),
                    type_name,
                    factory_name,
                    get_name(method),
                    bind<write_consume_args>(signature),
                    signature.params().empty() ? "" : ", ");
            }
        }
    }

    static void write_interface_override(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <typename D>
    class %T
    {
        D& shim() noexcept { return *static_cast<D*>(this); }
        D const& shim() const noexcept { return *static_cast<const D*>(this); }
    public:
        using % = xlang::%;
%    };
)";

        for (auto&& [interface_name, info] : get_interfaces(w, type))
        {
            if (info.overridable && !info.base)
            {
                auto type_name = info.type.TypeName();

                w.write(format,
                    type_name,
                    type_name,
                    info.type,
                    bind_each<write_consume_declaration>(info.type.MethodList()));
            }
        }
    }

    static void write_class_override_usings(writer& w, std::map<std::string, interface_info> const& required_interfaces)
    {
        std::map<std::string_view, std::set<std::string>> method_usage;

        for (auto&& [interface_name, info] : required_interfaces)
        {
            for (auto&& method : info.type.MethodList())
            {
                method_usage[get_name(method)].insert(interface_name);
            }
        }

        for (auto&& [method_name, interfaces] : method_usage)
        {
            if (interfaces.size() <= 1)
            {
                continue;
            }

            for (auto&& interface_name : interfaces)
            {
                w.write("        using impl::consume_t<D, %>::%;\n",
                    interface_name,
                    method_name);
            }
        }
    }

    static void write_class_override(writer& w, TypeDef const& type)
    {
        auto factories = get_factories(w, type);
        bool has_composable_factories{};

        for (auto&& [interface_name, factory] : factories)
        {
            if (factory.composable && !empty(factory.type.MethodList()))
            {
                has_composable_factories = true;
                break;
            }
        }

        if (!has_composable_factories)
        {
            return;
        }

        auto format = R"(    template <typename D, typename... Interfaces>
    struct %T :
        implements<D%, composing, Interfaces...>,
        impl::require<D%>,
        impl::base<D, %%>%
    {
        using composable = %;
    protected:
%%    };
)";

        auto type_name = type.TypeName();
        auto interfaces = get_interfaces(w, type);

        w.write(format,
            type_name,
            bind<write_class_override_implements>(interfaces),
            bind<write_class_override_requires>(interfaces),
            type_name,
            bind<write_class_override_bases>(type),
            bind<write_class_override_defaults>(interfaces),
            type_name,
            bind<write_class_override_constructors>(type_name, factories),
            bind< write_class_override_usings>(interfaces));
    }

    static void write_interface_requires(writer& w, TypeDef const& type)
    {
        auto interfaces = get_interfaces(w, type);

        if (interfaces.empty())
        {
            return;
        }

        w.write(",\n        impl::require<%", type);

        for (auto&& [name, info] : interfaces)
        {
            w.write(", %", name);
        }

        w.write('>');
    }

    static void write_interface_usings(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto interfaces_plus_self = get_interfaces(w, type);
        interfaces_plus_self[std::string{ type_name }] = interface_info{ type };
        std::map<std::string_view, std::set<std::string>> method_usage;

        for (auto&& [interface_name, info] : interfaces_plus_self)
        {
            for (auto&& method : info.type.MethodList())
            {
                method_usage[get_name(method)].insert(interface_name);
            }
        }

        for (auto&& [method_name, interfaces] : method_usage)
        {
            if (interfaces.size() <= 1)
            {
                continue;
            }

            for (auto&& interface_name : interfaces)
            {
                w.write("        using impl::consume_t<%, %>::%;\n",
                    type_name,
                    interface_name,
                    method_name);
            }
        }
    }

    static void write_class_usings(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto default_interface = get_default_interface(type);
        auto default_interface_name = w.write_temp("%", default_interface);
        std::map<std::string_view, std::set<std::string>> method_usage;

        for (auto&& [interface_name, info] : get_interfaces(w, type))
        {
            if (info.defaulted && !info.base)
            {
                for (auto&& method : info.type.MethodList())
                {
                    method_usage[get_name(method)].insert(default_interface_name);
                }
            }
            else
            {
                for (auto&& method : info.type.MethodList())
                {
                    method_usage[get_name(method)].insert(interface_name);
                }
            }
        }

        for (auto&& [method_name, interfaces] : method_usage)
        {
            if (interfaces.size() <= 1)
            {
                continue;
            }

            for (auto&& interface_name : interfaces)
            {
                if (default_interface_name == interface_name)
                {
                    w.write("        using %::%;\n",
                        interface_name,
                        method_name);
                }
                else
                {
                    w.write("        using impl::consume_t<%, %>::%;\n",
                        type_name,
                        interface_name,
                        method_name);
                }
            }
        }

    }

    static void write_interface(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };

        if (empty(generics))
        {
            auto format = R"(    struct XLANG_EBO % :
        Windows::Foundation::IXlangObject,
        impl::consume_t<%>%
    {
        %(std::nullptr_t = nullptr) noexcept {}
        %(void* ptr, take_ownership_from_abi_t) noexcept : Windows::Foundation::IXlangObject(ptr, take_ownership_from_abi) {}
%%    };
)";

            w.write(format,
                type_name,
                type_name,
                bind<write_interface_requires>(type),
                type_name,
                type_name,
                bind<write_interface_usings>(type),
                bind<write_interface_extensions>(type));
        }
        else
        {
            type_name = remove_tick(type_name);

            auto format = R"(    template <%>
    struct XLANG_EBO % :
        Windows::Foundation::IXlangObject,
        impl::consume_t<%>%
    {
        %(std::nullptr_t = nullptr) noexcept {}
        %(void* ptr, take_ownership_from_abi_t) noexcept : Windows::Foundation::IXlangObject(ptr, take_ownership_from_abi) {}
%%    };
)";

            w.write(format,
                bind<write_generic_typenames>(generics),
                type_name,
                type,
                bind<write_interface_requires>(type),
                type_name,
                type_name,
                bind<write_interface_usings>(type),
                bind<write_interface_extensions>(type));
        }
    }

    static void write_delegate(writer& w, TypeDef const& type)
    {
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        auto type_name = type.TypeName();

        if (!empty(generics))
        {
            type_name = remove_tick(type_name);

            auto format = R"(    template <%>
)";

            w.write(format, bind<write_generic_typenames>(generics));
        }

        auto format = R"(    struct % : Windows::Foundation::IUnknown
    {
        %(std::nullptr_t = nullptr) noexcept {}
        %(void* ptr, take_ownership_from_abi_t) noexcept : Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> %(L lambda);
        template <typename F> %(F* function);
        template <typename O, typename M> %(O* object, M method);
        template <typename O, typename M> %(com_ptr<O>&& object, M method);
        template <typename O, typename M> %(weak_ref<O>&& object, M method);
        % operator()(%) const;
    };
)";

        method_signature signature{ get_delegate_method(type) };

        w.write(format,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            signature.return_signature(),
            bind<write_consume_params>(signature));
    }

    static void write_delegate_implementation(writer& w, TypeDef const& type)
    {
        auto format = R"(    template <%> struct delegate<%>
    {
        template <typename H>
        struct type : implements_delegate<%, H>
        {
            type(H&& handler) : implements_delegate<%, H>(std::forward<H>(handler)) {}

            xlang_error_info* XLANG_CALL Invoke(%) noexcept final
            {
                try
                {
                    %;
                    return nullptr;
                }
                catch (...)
                {%
                    return to_xlang_error();
                }
            }
        };
    };
)";

        w.param_names = true;
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        method_signature signature{ get_delegate_method(type) };

        w.write(format,
            bind<write_generic_typenames>(generics),
            type,
            type,
            type,
            bind<write_abi_params>(signature),
            bind<write_delegate_upcall>(signature),
            ""); // TODO: resolve
    }

    static void write_delegate_definition(writer& w, TypeDef const& type)
    {
        auto generics = type.GenericParam();
        auto guard{ w.push_generic_params(generics) };
        auto type_name = type.TypeName();
        method_signature signature{ get_delegate_method(type) };

        if (!empty(generics))
        {
            auto format = R"(    template <%> template <typename L> %<%>::%(L handler) :
        %(impl::make_delegate<%<%>>(std::forward<L>(handler)))
    {
    }
    template <%> template <typename F> %<%>::%(F* handler) :
        %([=](auto&&... args) { return handler(args...); })
    {
    }
    template <%> template <typename O, typename M> %<%>::%(O* object, M method) :
        %([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <%> template <typename O, typename M> %<%>::%(com_ptr<O>&& object, M method) :
        %([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <%> template <typename O, typename M> %<%>::%(weak_ref<O>&& object, M method) :
        %([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    template <%> % %<%>::operator()(%) const
    {%
        check_xlang_error((*(impl::abi_t<%<%>>**)this)->Invoke(%));%
    }
)";

            type_name = remove_tick(type_name);

            w.write(format,
                bind<write_generic_typenames>(generics),
                type_name,
                bind_list(", ", generics),
                type_name,
                type_name,
                type_name,
                bind_list(", ", generics),
                bind<write_generic_typenames>(generics),
                type_name,
                bind_list(", ", generics),
                type_name,
                type_name,
                bind<write_generic_typenames>(generics),
                type_name,
                bind_list(", ", generics),
                type_name,
                type_name,
                bind<write_generic_typenames>(generics),
                type_name,
                bind_list(", ", generics),
                type_name,
                type_name,
                bind<write_generic_typenames>(generics),
                type_name,
                bind_list(", ", generics),
                type_name,
                type_name,
                bind<write_generic_typenames>(generics),
                signature.return_signature(),
                type_name,
                bind_list(", ", generics),
                bind<write_consume_params>(signature),
                bind<write_consume_return_type>(signature),
                type_name,
                bind_list(", ", generics),
                bind<write_abi_args>(signature),
                bind<write_consume_return_statement>(signature));
        }
        else
        {
            auto format = R"(    template <typename L> %::%(L handler) :
        %(impl::make_delegate<%>(std::forward<L>(handler)))
    {
    }
    template <typename F> %::%(F* handler) :
        %([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> %::%(O* object, M method) :
        %([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> %::%(com_ptr<O>&& object, M method) :
        %([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> %::%(weak_ref<O>&& object, M method) :
        %([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline % %::operator()(%) const
    {%
        check_xlang_error((*(impl::abi_t<%>**)this)->Invoke(%));%
    }
)";

            w.write(format,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                type_name,
                signature.return_signature(),
                type_name,
                bind<write_consume_params>(signature),
                bind<write_consume_return_type>(signature),
                type_name,
                bind<write_abi_args>(signature),
                bind<write_consume_return_statement>(signature));
        }
    }

    static void write_struct_field(writer& w, std::pair<std::string_view, std::string> const& field)
    {
        w.write("        @ %;\n",
            field.second,
            field.first);
    }

    static void write_struct_equality(writer& w, std::vector<std::pair<std::string_view, std::string>> const& fields)
    {
        for (size_t i = 0; i != fields.size(); ++i)
        {
            w.write(" left.% == right.%", fields[i].first, fields[i].first);

            if (i + 1 != fields.size())
            {
                w.write(" &&");
            }
        }
    }

    static bool write_structs(writer& w, std::vector<TypeDef> const& types)
    {
        auto format = R"(    struct %
    {
%    };
    inline bool operator==(% const& left, % const& right)%
    {
        return%;
    }
    inline bool operator!=(% const& left, % const& right)%
    {
        return !(left == right);
    }
)";

        if (types.empty())
        {
            return false;
        }

        struct complex_struct
        {
            complex_struct(writer& w, TypeDef const& type) :
                type(type),
                is_noexcept(!has_reference(type))
            {
                for (auto&& field : type.FieldList())
                {
                    fields.emplace_back(field.Name(), w.write_temp("%", field.Signature().Type()));
                }
            }

            static bool has_reference(TypeDef const&)
            {
                return false;
            };

            TypeDef type;
            std::vector<std::pair<std::string_view, std::string>> fields;
            bool is_noexcept{ false };
        };

        std::vector<complex_struct> structs;

        for (auto&& type : types)
        {
            structs.emplace_back(w, type);
        }

        auto depends = [](writer& w, complex_struct const& left, complex_struct const& right)
        {
            for (auto&& field : left.fields)
            {
                if (w.write_temp("%", right.type) == field.second)
                {
                    return true;
                }
            }

            return false;
        };

        for (size_t left = 0; left < structs.size(); ++left)
        {
            for (size_t right = left + 1; right < structs.size(); ++right)
            {
                if (depends(w, structs[left], structs[right]))
                {
                    // Left depends on right, therefore move right in front of left.
                    complex_struct temp = std::move(structs[right]);
                    structs.erase(structs.begin() + right);
                    structs.insert(structs.begin() + left, std::move(temp));

                    // Start over from the newly inserted struct.
                    right = structs.size();
                    --left;
                }
            }
        }

        bool promote = false;
        auto cpp_namespace = w.write_temp("@", w.type_namespace);

        for (auto&& type : structs)
        {
            auto name = type.type.TypeName();
            std::string_view is_noexcept = type.is_noexcept ? " noexcept" : "";

            w.write(format,
                name,
                bind_each<write_struct_field>(type.fields),
                name,
                name,
                is_noexcept,
                bind<write_struct_equality>(type.fields),
                name,
                name,
                is_noexcept);

            for (auto&& field : type.fields)
            {
                if (field.second.find(':') == std::string::npos)
                {
                    continue;
                }

                if (!starts_with(field.second, cpp_namespace))
                {
                    promote = true;
                }
            }
        }

        return promote;
    }

    static void write_slow_class_requires(writer& w, TypeDef const& type)
    {
        bool first{ true };

        for (auto&& [interface_name, info] : get_interfaces(w, type))
        {
            if (!info.defaulted || info.base)
            {
                if (first)
                {
                    first = false;
                    w.write(",\n        impl::require<%", type.TypeName());
                }

                w.write(", %", interface_name);
            }
        }

        if (!first)
        {
            w.write('>');
        }
    }

    static void write_class_base(writer& w, TypeDef const& type)
    {
        bool first{ true };

        for (auto&& base : get_bases(type))
        {
            if (first)
            {
                first = false;
                w.write(",\n        impl::base<%", type.TypeName());
            }

            w.write(", %", base);
        }

        if (!first)
        {
            w.write('>');
        }
    }

    static void write_constructor_declarations(writer& w, TypeDef const& type, std::map<std::string, factory_info> const& factories)
    {
        w.async_types = false;
        auto type_name = type.TypeName();

        for (auto&& [factory_name, factory] : factories)
        {
            if (factory.activatable)
            {
                if (!factory.type)
                {
                    w.write("        %();\n", type_name);
                }
                else
                {
                    for (auto&& method : factory.type.MethodList())
                    {
                        method_signature signature{ method };

                        w.write("        %(%);\n",
                            type_name,
                            bind<write_consume_params>(signature));
                    }
                }
            }
            else if (factory.composable && factory.visible)
            {
                for (auto&& method : factory.type.MethodList())
                {
                    method_signature signature{ method };
                    auto& params = signature.params();
                    params.resize(params.size() - 2);

                    w.write("        %(%);\n",
                        type_name,
                        bind<write_consume_params>(signature));
                }
            }
        }
    }

    static void write_constructor_definition(writer& w, MethodDef const& method, std::string_view const& type_name, TypeDef const& factory)
    {
        w.async_types = false;

        method_signature signature{ method };

        auto format = R"(    inline %::%(%) :
        %(impl::call_factory<%, %>([&](auto&& f) { return f.%(%); }))
    {
    }
)";

        w.write(format,
            type_name,
            type_name,
            bind<write_consume_params>(signature),
            type_name,
            type_name,
            factory,
            get_name(method),
            bind<write_consume_args>(signature));
    }

    static void write_composable_constructor_definition(writer& w, MethodDef const& method, std::string_view const& type_name, TypeDef const& factory)
    {
        method_signature signature{ method };
        auto& params = signature.params();
        auto inner_param = params.back().first.Name();
        params.pop_back();
        auto base_param = params.back().first.Name();
        params.pop_back();

        auto format = R"(    inline %::%(%)
    {
        Windows::Foundation::IXlangObject %, %;
        *this = impl::call_factory<%, %>([&](auto&& f) { return f.%(%%%, %); });
    }
)";

        w.write(format,
            type_name,
            type_name,
            bind<write_consume_params>(signature),
            base_param,
            inner_param,
            type_name,
            factory,
            get_name(method),
            bind<write_consume_args>(signature),
            params.empty() ? "" : ", ",
            base_param,
            inner_param);
    }


    static void write_static_declaration(writer& w, std::pair<std::string const, factory_info> const& factory)
    {
        if (!factory.second.statics)
        {
            return;
        }

        for (auto&& method : factory.second.type.MethodList())
        {
            method_signature signature{ method };
            auto method_name = get_name(method);
            w.async_types = is_async(method, signature);

            w.write("        static % %(%);\n",
                signature.return_signature(),
                method_name,
                bind<write_consume_params>(signature));

            if (is_add_overload(method))
            {
                auto format = R"(        using %_revoker = impl::factory_event_revoker<%, &impl::abi_t<%>::remove_%>;
        static %_revoker %(auto_revoke_t, %);
)";

                w.write(format,
                    method_name,
                    factory.second.type,
                    factory.second.type,
                    method_name,
                    method_name,
                    method_name,
                    bind<write_consume_params>(signature));
            }
        }
    }

    static void write_static_definitions(writer& w, MethodDef const& method, std::string_view const& type_name, TypeDef const& factory)
    {
        method_signature signature{ method };
        auto method_name = get_name(method);
        w.async_types = is_async(method, signature);

        {
            auto format = R"(    inline % %::%(%)
    {
        %impl::call_factory<%, %>([&](auto&& f) { return f.%(%); });
    }
)";

            w.write(format,
                signature.return_signature(),
                type_name,
                method_name,
                bind<write_consume_params>(signature),
                signature.return_signature() ? "return " : "",
                type_name,
                factory,
                method_name,
                bind<write_consume_args>(signature));
        }

        if (is_add_overload(method))
        {
            auto format = R"(    inline %::%_revoker %::%(auto_revoke_t, %)
    {
        auto f = get_activation_factory<%, %>();
        return { f, f.%(%) };
    }
)";

            w.write(format,
                type_name,
                method_name,
                type_name,
                method_name,
                bind<write_consume_params>(signature),
                type_name,
                factory,
                method_name,
                bind<write_consume_args>(signature));
        }
    }

    static void write_class_definitions(writer& w, TypeDef const& type)
    {
        if (settings.component_opt && settings.component_filter.includes(type))
        {
            return;
        }

        auto type_name = type.TypeName();

        for (auto&& [interface_name, factory] : get_factories(w, type))
        {
            if (factory.activatable)
            {
                if (!factory.type)
                {
                    auto format = R"(    inline %::%() :
        %(impl::call_factory<%>([](auto&& f) { return f.template ActivateInstance<%>(); }))
    {
    }
)";

                    w.write(format,
                        type_name,
                        type_name,
                        type_name,
                        type_name,
                        type_name);
                }
                else
                {
                    w.write_each<write_constructor_definition>(factory.type.MethodList(), type_name, factory.type);
                }
            }
            else if (factory.composable && factory.visible)
            {
                w.write_each<write_composable_constructor_definition>(factory.type.MethodList(), type_name, factory.type);
            }
            else if (factory.statics)
            {
                w.write_each<write_static_definitions>(factory.type.MethodList(), type_name, factory.type);
            }
        }
    }

    static void write_slow_class(writer& w, TypeDef const& type, coded_index<TypeDefOrRef> const& base_type)
    {
        auto type_name = type.TypeName();
        auto factories = get_factories(w, type);

        auto format = R"(    struct XLANG_EBO % : %%%
    {
        %(std::nullptr_t) noexcept {}
        %(void* ptr, take_ownership_from_abi_t) noexcept : %(ptr, take_ownership_from_abi) {}
%%%    };
)";

        w.write(format,
            type_name,
            base_type,
            bind<write_class_base>(type),
            bind<write_slow_class_requires>(type),
            type_name,
            type_name,
            base_type,
            bind<write_constructor_declarations>(type, factories),
            bind<write_class_usings>(type),
            bind_each<write_static_declaration>(factories));
    }

    static void write_static_class(writer& w, TypeDef const& type)
    {
        auto type_name = type.TypeName();
        auto factories = get_factories(w, type);

        auto format = R"(    struct %
    {
        %() = delete;
%    };
)";

        w.write(format,
            type_name,
            type_name,
            bind_each<write_static_declaration>(factories));
    }

    static void write_class(writer& w, TypeDef const& type)
    {
        if (auto default_interface = get_default_interface(type))
        {
            write_slow_class(w, type, default_interface);
        }
        else
        {
            write_static_class(w, type);
        }
    }

    static void write_std_hash(writer& w, TypeDef const& type)
    {
        auto generics = type.GenericParam();

        w.write("    template<%> struct hash<xlang::%> : xlang::impl::hash_base<xlang::%> {};\n",
            bind<write_generic_typenames>(generics),
            type,
            type);
    }

    static void write_namespace_special(writer& w, std::string_view const& namespace_name, cache const& /*c*/)
    {
        if (namespace_name == "Foundation.Collections")
        {
            w.write(strings::base_collections);
            w.write(strings::base_collections_base);
            w.write(strings::base_collections_input_iterable);
            w.write(strings::base_collections_input_vector_view);
            w.write(strings::base_collections_input_map_view);
            w.write(strings::base_collections_input_vector);
            w.write(strings::base_collections_input_map);
            w.write(strings::base_collections_vector);
            w.write(strings::base_collections_map);
        }
    }
}
